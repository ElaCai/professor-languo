/*
 * Copyright IBM Corp. 2015
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package com.ibm.watson.developer_cloud.professor_languo.pipeline.primary_search;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import org.apache.lucene.search.BooleanClause;
import org.apache.lucene.search.BooleanClause.Occur;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.search.spans.SpanNearQuery;
import org.apache.lucene.search.spans.SpanTermQuery;
import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.index.Term;

import com.ibm.watson.developer_cloud.professor_languo.data_model.Question;
import com.ibm.watson.developer_cloud.professor_languo.exception.SearchException;
import com.ibm.watson.developer_cloud.professor_languo.model.stack_exchange.StackExchangeQuestion;
import com.ibm.watson.developer_cloud.professor_languo.model.stack_exchange.StackExchangeConstants.IndexDocumentFieldName;

/**
 * A superclass for QueryGenerators using the SpanNearQuery class form Lucene in order to make
 * n-gram queries.
 */

public abstract class SpanQueryGenerator implements QueryComponent {
  protected boolean inOrder = false;
  /**
   * IMPORTANT: Each entry fieldsToSearch must have a corresponding boost value in boostValues
   */
  protected String[] fieldsToSearch = {IndexDocumentFieldName.THREAD_TITLE.toString(),
      IndexDocumentFieldName.THREAD_TEXT.toString(), IndexDocumentFieldName.ACCEPTED_ANSWER_TEXT.toString(),
      IndexDocumentFieldName.TOP_VOTED_ANSWER_TEXT.toString()};
  protected int[] boostValues = {2, 1, 1, 1};
  /**
   * The fuzzFactor determines how far the query should match a phrase. For example, if
   * fuzzFactor=2, the bigram query generator would match all phrases that has the two tokens
   * separated by at most 2 words.
   */
  protected int fuzzFactor = 0;

  /**
   * Create a boosted unigram query for the {@link Question}. The boost query matches any Lucene
   * Documents whose fields specified in {@link #fieldsToSearch} contain any unigram tokens in the
   * {@link Question}'s title field. The {@link #boostValues} represent the importance of certain
   * fields over others.
   * 
   * @param question The {@link Question} from the pipeline.
   * @param analyzer The Lucene {@link Analyzer} used for tokenizing text fields.
   * @return The corresponding Lucene {@link Query}
   * @throws SearchException
   */
  protected Query createBoostUnigramQuery(Question question, Analyzer analyzer) throws SearchException {
    List<String> tokens;
    StackExchangeQuestion queryQuestion = (StackExchangeQuestion) question;
    String title = queryQuestion.getTitleText();
    BooleanQuery query = new BooleanQuery();

    try {
      tokens = AnalyzerUtils.collectTokens(analyzer, title);
      // Loop through all tokens
      for (int idx = 0; idx < tokens.size(); idx++) {
        // For each field to search for
        for (int fieldIdx = 0; fieldIdx < fieldsToSearch.length; fieldIdx++) {
          TermQuery stq = new TermQuery(new Term(fieldsToSearch[fieldIdx], tokens.get(idx).trim()));
          stq.setBoost(boostValues[fieldIdx]);

          query.add(stq, Occur.SHOULD);
        } // Repeat for every field in fieldsToSearch
      } // Repeat for each token
    } catch (IOException e) {
      throw new SearchException(e);
    }

    return query;
  }

  /**
   * Create a boosted n-gram query for the {@link Question}. The query is generated by linking
   * {@code n} tokens to create a {@link SpanNearQuery}. The {@link #fuzzFactor} specifies the
   * maximum distance by which the {@code n} tokens can be apart. The query generated matches any
   * Lucene document that contains {@code n} tokens from the {@link Question}'s title field within
   * {@link #fuzzFactor} distance of any field in {@link #fieldsToSearch}. The {@link #boostValues}
   * represent the importance of each respective field in {@link fieldsToSearch}.
   * 
   * @param question The {@link Question} from the pipeline.
   * @param analyzer The Lucene {@link Analyzer} used for tokenizing text fields.
   * @param n
   * @return The corresponding Lucene {@link Query}
   * @throws SearchException
   */
  protected Query createNgramSpanQuery(Question question, Analyzer analyzer, int n) throws SearchException {
    if (n == 1)
      return createBoostUnigramQuery(question, analyzer);

    return mergeBooleanQueries((BooleanQuery) createNgramQueryRecursive(question, analyzer, n),
        (BooleanQuery) createNgramSpanQuery(question, analyzer, n - 1));
  }

  private Query createNgramQueryRecursive(Question question, Analyzer analyzer, int n) throws SearchException {
    List<String> tokens;
    StackExchangeQuestion queryQuestion = (StackExchangeQuestion) question;
    String title = queryQuestion.getTitleText();
    List<SpanTermQuery> termQueries = new ArrayList<SpanTermQuery>();
    BooleanQuery query = new BooleanQuery();

    try {
      tokens = AnalyzerUtils.collectTokens(analyzer, title);
      // Loop through all tokens
      for (int idx = 0; idx < tokens.size() - (n - 1); idx++) {
        // For each field to search for
        for (int fieldIdx = 0; fieldIdx < fieldsToSearch.length; fieldIdx++) {
          // Make n-gram term query
          for (int t = 0; t < n; t++) {
            SpanTermQuery stq = new SpanTermQuery(new Term(fieldsToSearch[fieldIdx], tokens.get(idx + t).trim()));
            stq.setBoost((float) (boostValues[fieldIdx] / 2.0));
            termQueries.add(stq);
          }
          SpanNearQuery spanTitleQuery = new SpanNearQuery(
              (SpanTermQuery[]) termQueries.toArray(new SpanTermQuery[termQueries.size()]), fuzzFactor, inOrder);
          query.add(spanTitleQuery, Occur.SHOULD);
          termQueries.clear();
        } // Repeat for every field in fieldsToSearch
      } // Repeat for each token
    } catch (IOException e) {
      throw new SearchException(e);
    }

    return query;
  }

  protected BooleanQuery mergeBooleanQueries(BooleanQuery q1, BooleanQuery q2) {
    BooleanClause[] clauses = q1.getClauses();
    for (BooleanClause c : clauses)
      q2.add(c);
    return q2;
  }
}
